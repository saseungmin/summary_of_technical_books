---
sidebar_position: 3
---

# 🌈 Chapter 2 : 값

<details><summary>Table of Contents</summary>

- 배열 [:link:](#-배열)
  - 유사 배열 [:link:](#-유사-배열)
- 문자열 [:link:](#-문자열)
- 숫자 [:link:](#-숫자)
  - 숫자 구문 [:link:](#-숫자-구문)
  - 작은 소수 값 [:link:](#-작은-소수-값)
  - 정수인지 확인 [:link:](#-정수인지-확인)
  - 32비트 (부호 있는) 정수 [:link:](#-32비트-부호-있는-정수)
- 특수 값 [:link:](#-특수-값)
  - 값이 아닌 값 [:link:](#-값이-아닌-값)
  - Undefined [:link:](#-undefined)
  - 특수 숫자 [:link:](#-특수-숫자)
  - 특이한 동등 비교 [:link:](#-특이한-동등-비교)
- 값 vs 레퍼런스 [:link:](#-값-vs-레퍼런스)
- 정리하기 [:link:](#-정리하기)

</details>


## 🎯 배열
- 자바스크립트 배열은 타입이 엄격한 다른 언어와 달리 **문자열, 숫자, 객체 심지어 다른 배열이나 어떤 타입의 값**이라도 담을 수 있는 그릇이다.

```javascript
var a = [1, "2", [3]];

a.length; // 3
a[0] === 1; // true
a[2][0] === 3; // true
```
- 배열 크기는 미리 정하지 않고도 선언할 수 있으며 원하는 값을 추가하면 된다.

```javascript
var a = [];

a.length; // 0
a[0] = 1;
a[1] = "2";
a[2] = [3];
a.length; // 3
```

- 빈 슬롯이 있는 배열을 다룰 떄는 조심해야 한다.

```javascript
var a = [];

a[0] = 1;
// a[1]이 빠짐
a[2] = [3];
a.length; // 3
```

- 실행은 되지만 이런 코드에서 중간에 건너뛴 빈 슬롯은 혼란을 줄 수 있다.
- 위 예제에서 `a[1]`슬롯 값은 `undefinded`가 될 거 같지만, 명시적으로 `a[1] = undefined` 세팅한 것과 똑같지는 않다.
- 배열 인덱스는 숫자인데, 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다. (**배열 `length`가 증가하지는 않는다.**)

```javascript
var a = [];
a[0] = 1;
a["foobar"] = 2;

a.length; // 1
a["foobar"] // 2
a.foobar; // 2
```

- 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 거 같은 결과가 초래된다.

```javascript
var a = [];

a["13"] = 42;
a.length; // 14
```

### 📚 유사 배열
- 유사 배열 값(숫자 인덱스가 가리키는 값들의 집합)을 진짜 배열로 바꾸고 싶을 때가 있다.
- 이럴 때는 배열 유틸리티 함수(`indexOf()`, `forEach()`, `concat()` 등)를 사용하여 해결하는 것이 일반적이다.

```javascript
function foo() {
  // arguments 객체를 사용하는 것은 ES6부터 비 권장
  var arr = Array.prototype.slice.call(arguments);
  arr.push("bam");
  console.log(arr);
}

foo("bar", "baz"); // ["bar", "baz", "bam"]
```
- 위와 같은 변환은 `slice()` 함수의 기능을 차용하는 방법으로 가장 많이 사용한다.
- ES6 부터는 기본 내장 함수 `Array.from()`이 이 일을 대신한다.

```javascript
var arr = Array.from(arguments);
```

## 🎯 문자열
- 흔히 문자열은 단지 문자의 배열이라고 생각한다.
- 자바스크립트 문자열은 실제로 생김새만 비슷할 뿐 문자 배열과 같이 않다.

```javascript
var a = 'foo';
var b = ['f', 'o', 'o'];
```
- 문자열은 배열과 겉모습이 닮았다.(유사 배열이다.).
- 둘 다 `length` 프로퍼티, `indexOf()` 메서드(ES5 배열에만 있음), `concat()` 메서드를 가진다

```javascript
a.length; // 3
b.length; // 3

a.indexOf('o'); // 1
b.indexOf('o'); // 1

var c = a.concat('bar'); // foobar
var d = b.concat(['b', 'a', 'r']); // ['f', 'o', 'o', 'b', 'a', 'r']

a === c; // false
b === d; // false

a; // foo
b; // ['f', 'o', 'o']
```
- 그렇다면 기본적으로는 둘 다 '문자의 배열'이라고 할 수 있을까? 그렇지 않다.

```javascript
a[i] = '0';
b[i] = '0';

a; // foo
b; // ['f', 'O', 'o']
```
- 문자열은 불변 값(`Immutable`) 이지만 배열은 가변 값(`Mutable`) 이다.
- `a[1]` 처럼 문자열의 특정 문자를 접근하는 형태가 모든 자바스크립트 엔진에서 유효한 것은 아니다. (익스플로러 구버전은 문법 에러로 인식)
- 문자열은 불변 값이므로 **문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다.**
- 반면에 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.

```javascript
c = a.toUpperCase();
a === c; //false
a; // foo
c; // FOO

b.push('!');
b; // ['f','O', 'o', '!']
```

- 문자열을 다룰 때 유용한 대부분의 배열 메서드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메서드를 빌려 쓸 수는 있다.

```javascript
a.join; // undefined
a.map; // undefined

var c = Array.prototype.join.call(a, '-');
var d = Array.prototype.map.call(a, function(v) {
  return v.toUpperCase() + '.';
}).join('');

c; // "f-o-o"
d; // "F.O.O."
```

- 문자열의 순서로 거꾸로 뒤집을 수 있다.
- 배열에는 `reverse()` 라는 가변 메서드가 준비되어 있지만, 문자열은 그렇지 않다.

```javascript
a.reverse; // undefined

b.reverse(); // ["!", "o", "o", "f"]
b; // ["!", "o", "o", "f"]
```
- 문자열은 불변 값이라 바로 변경되지 않으므로 배열의 가변 메서드는 통하지 않고, 그래서 '빌려 쓰는 것' 또한 안 된다.

```javascript
Array.prototype.reverse.call(a);
// Cannot assign to read only property '0' of object '[object String]'
```

- 문자열을 배열로 바꾸고 원하는 작업을 수행한 후 다시 문자열로 되돌리는 것이 또 다른 꼼수(Hack)이다.
- 하지만 복잡한(유니코드)문자가 섞여 있는 경우 이 방법은 통하지 않는다.

```javascript
var c = a.split('').reverse().join('');
```

## 🎯 숫자
- **자바스크립트의 숫자 타입은 `number`가 유일**하며 정수(integer), 부동 소수점 숫자를 모두 아우른다.
- 따라서 자바스크립트의 정수는 **부동 소수점 값이 없는 값이다.**(42.0은 정수 42와 같다.)

### 📚 숫자 구문
- 자바스크립트 숫자 리터럴은 다음과 같이 10진수 리터럴로 표시한다.
- 소수점 앞 정수가 0이면 생략 가능하다.
- 소수점 이하가 0일 때도 생략 가능하다.
```javascript
var a = 42;
var b = 42.3;

var a = 0.42;
var b = .42;

var a = 42.0;
var b = 42.;
```
- 아주 크거나 아주 작은 숫자는 지수형으로 표시하며, `toExponential()` 메서드의 결괏값과 같다.

```javascript
var a = 5E10;
a; // 50000000000
a.toExponential() // "5e+10"
```

- 숫자 값은 `Number` 객체 래퍼(Wrapper)로 박싱(Boxing)할 수 있기 때문에 `Number.prototype` 메서드로 접근할 수도 있다.

```javascript
var a = 42.59;

a.toFixed(0); // "43"
a.toFixed(1); // "42.6"
a.toFixed(2); // "42.59"
```
- 실제로는 숫자 값을 문자열 형태로 반환하며, 원래 값의 소수점 이하 숫자보다 더 많은 자릿수를 지정하면 그만큼 0이 우측에 붙는다.
- 소수점일 경우엔 프로퍼티 접근자가 아닌 숫자 리터럴의 일부로 해석되므로, 연산자를 사용할 떄는 조심해야 한다.

```javascript
42.toFixed(3); // Uncaught SyntaxError: Invalid or unexpected token

(42).toFixed(3); // "42.000"
0.42.toFixed(3); // "0.420"
42..toFixed(3); // "42.000"
```
- `42.toFixed(3);`가 구문 에러가 나는 이유는 `42.` 리터럴(맞는 표현)의 일부가 되어 버려 `.toFixed` 메서드에 접근할 수단이 없기 때문이다.
- 숫자 리터럴은 2진, 8진, 16진 등 다른 진번으로도 나타낼 수 있다.
- ES6+ 엄격 모드(strict mode)에서는 `0363`처럼 `0`을 앞에 붙여 8진수를 표시하지 못한다.

### 📚 작은 소수 값
- 다음 예제는 이진 부동 소수점 숫자의 부작용 문제이다.
- 자바스크립트만의 문제가 아니라 IEEE 754 표준을 따르는 모든 언어에서 공통적인 문제이다.

```javascript
0.1 + 0.2 === 0.3 // false
```
- 이 문제는 이진 부동 소수점으로 나타낸 `0.1`과 `0.2`는 원래 숫자와 일치하지 않는다.
- 그래서 둘을 더한 결과 역시 정확한 0.3이 아니다. 실제로는 `0.300000000004`에 가깝지만, 가깝다고해도 같은 것은 아니다.
- 많은 애플리케이션이(대부분) 전체수(0과 양수를 포함한 숫자)만을, 그것도 기껏해야 백만이나 조 단위 규모의 숫자를 다룬다.
- 이런 상황이라면 안심하고 자바스크립트의 숫자 연산 기능을 믿고 써도 된다.
- 그렇다면 `0.1 + 0.2` 과 `0.3`, 두 숫자는 미세한 반올림 오차를 허용 공차로 처리하는 방법을 사용한다.
- 이렇게 미세한 오차를 **머신 입실론(컴퓨터가 이해할 수 있는 가장 작은 숫자 단위)** 이라고 하는데, 자바스크립트 숫자의 머신 입실론은 `2^-52^`이다.
- ES6부터는 이 값이 `Number.EPSILON`으로 미리 정의되어 있으므로 필요시 사용하면 되고, ES6 이전 브라우저는 폴리필을 대신 사용한다.

```javascript
if(!Number.EPSILON) {
  Number.EPSILON = Math.pow(2,-52);
}
```

- `Number.EPSILON`으로 두 숫자의 (반올림 허용 오차 이내의) 동등함을 비교할 수 있다.

```javascript
function numbersCloseEnoughToEqual(n1, n2) {
  return Math.abs(n1 - n2) < Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual(a, b); // true
numbersCloseEnoughToEqual(0.00000001, 0.00000002); // false
```

### 📚 정수인지 확인
- ES6부터는 `Number.isInteger()`로 어떤 값의 정수 여부를 확인한다.

```javascript
Number.isInteger(42); // true
Number.isInteger(42.000); // true
Number.isInteger(42.3); // false
```

- 안전한 정수 여부는 ES6부터 `Number.isSafeInteger()`로 체크한다.

```javascript
Number.isSafeInteger(Number.MAX_SAFE_INTEGER); // true
Number.isSafeInteger(Math.pow(2, 53)); // false
Number.isSafeInteger(Math.pow(2, 53) - 1); // true
```

### 📚 32비트 (부호 있는) 정수
- 정수의 안전 범위가 대략 9조에 이르지만, 32비트 숫자에만 가능한 연산이 있으므로 실제 범위는 훨씬 줄어든다.
- 따라서 정수의 안전 범위는 `Math.pow(-2, 31)`에서 `Math.pow(2, 31) - 1` 까지이다.
- `a | 0` 과 같이 쓰면 숫자 값 ➡ 32 비트 부호 있는 정수로 강제변환을 한다.
- `|` 비트 연산자는 32비트 정수 값에만 쓸 수 있기 때문에 가능한 방법이다.

## 🎯 특수 값

### 📚 값이 아닌 값
- `undefinded` 타입의 값은 `undefinded` 밖에 없다. `null` 타입도 값은 `null`뿐이다.
- 그래서 이 둘은 **타입과 값이 항상 같다.**
- `null`은 식별자가 아닌 특별한 키워드이므로 `null`이라은 변수에 뭔가 할당할 수는 없다.
- 그렇지만 `undefined`는 식별자로 쓸 수 있다.

### 📚 Undefined
- 느슨한 모드에서는 전역 스코프에서 `undefined`란 식별자에 값을 할당할 수 있다.(절대 추천 X)

```javascript
function foo() {
  undefined = 2; // 좋지 못하다.
}

function foo() {
  "use strict";
  undefined = 2; // 타입 에러 발생
}
```

- 모드에 상관없이 `undefined`란 이름을 가진 지역 변수는 생성할 수 있다. (사용 X)

```javascript
function foo() {
  "use strict";
  var undefined = 2;
  console.log(undefined); // 2
}
```

- `undefined`는 내장 식별자로, 값은 `undefined`지만, 이 값은 `void` 연산자로도 얻을 수 있다.
- 표현식 `void __`는 어떤 값이든 무효로 만들어, 항상 결괏값을 `undefined`로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

```javascript
var a = 42;
console.log(void a, a); // undefined 42
```

- 관례에 따라 `void`만으로 `undefined` 값을 나타내려면 `void 0`이라고 쓴다. `void 0`, `void 1`, `undefined` 모두 같다.
- `void` 연산자는 값이 존재하는 곳에서 그 값이 `undefined`가 되어야 좋을 경우에만 사용해야 한다. (거의 사용하지 않는다.)

### 📚 특수 숫자

- 숫자 연산 시 두 피연산자가 전부 숫자가 아닐 경우 유효환 숫자가 나올 수 없으므로 그 결과는 `NaN` 이다.
- `NaN`은 숫자 아님보다는 유효하지 않은(invalid) 숫자, 실패한 숫자, 또는 몹쓸 숫자라고 하는 것이 더 정확하다.

```javascript
var a = 2 / 'foo'; // NaN

typeof a === 'number'; // true
```

- `NaN`은 경계 값의 일종으로 숫자 집합 내에서 특별한 종류의 에러 상황을 나타낸다.
- 어떤 변수값이 특수한 실패 숫자, 즉 `NaN`인지 여부를 확인할 때 `null`, `undefined`처럼 `NaN`도 직접 비교하고 싶지만 틀리다.
- `NaN`은 **다른 어떤 `NaN`과도 동등하지 않다.**
- 사실상 반사성(Reflexive)이 없는 유일무이한 값이다.
- 따라서 `NaN !== NaN`이다.
- `NaN`을 여부를 확일 할 때는 내장 전역 유틸리티 `isNaN()` 함수가 `NaN` 여부를 말해준다.
- 하지만 `isNaN()`는 치명적인 결함이 있는데 이 함수는 `NaN`의 의미를 너무 글자 그대로만 해석해서 실제로 인자 값이 숫자인이 여부를 평가하는 기능이 전부이다.

```javascript
var a = 2 / 'foo';
var b = 'foo';

a; // NaN
b; // 'foo'

window.isNaN(a); // true
window.isNaN(b); // true
```

- `foo`는 당연히 숫자가 아니지만, 그렇다고 `NaN`는 아니다.
- 이 버그는 자바스크립트 탄생 이후 오늘까지 계속됐다.
- ES6 부터는 `Number.isNaN()`이 등장하여 `NaN`여부를 안전하게 체크할 수 있다.
- 자바스크립트에서는 0으로 나누기 연산이 잘 정의되어 있어서 에러 없이 `Infinity(Number.POSITIVE_INFINITY)`라는 결과값이 나온다.

```javascript
var a = 1 / 0; // Infinity
var b = -1 / 0; // Infinity
```

- IEEE 754 명세에 따르면, 덧셈 등의 연산 결과가 너무 커서 표현하기 곤란할 때 가장 가까운 수로 반올림 모드가 결괏값을 정한다.
- 만약 무한을 무한으로 나누면 무한대또는 1이 나올거 같지만 수학책, 자바스크립트 모두 **무한대/무한대는 정의되지 않은 연산이며, 결괏값은 NaN이다**
- 유한한 양수를 무한대로 나누면 `0`이지만 유한한 음수를 무한대로 나누면??
- 자바스크립트에는 `0`과 `-0`이 존재한다.
- 음의 영은 표기만 `-0`으로 하는 것이 아니라 특정 수식의 연산 결과 또한 `-0`으로 떨어진다.

```javascript
var a = 0 / -3; // -0
var b = 0 * -3; // -0
```
- 덧셈과 뺄셈에는 `-0`이 나올 수가 없다.
- 명세에 의하면 `-0`을 문자열화 하면 항상 `"0"`이다.
- 반대로하면 있는 그대로 보여준다.

```javascript
+"-0"; // -0
Number("-0"); // -0
JSON.parse("-0"); // -0
JSON.stringify(-0); // "0"
```

- 확실하게 `-0`과 `0`을 구분하고 싶다 다음과 같이 해준다.

```javascript
function isNegZero(n) {
  n = Number(n);
  return (n === 0) && (1 / n === -Infinity);
}

isNegZero(-0); // true
isNegZero(0 / -3); //true
isNegZero(0); // false
```

- 이렇게 `-0`을 만든 이유는 값의 크기로 어떤 정보(ex. 애니메이션 프레임당 넘김 속도)와 그 값의 부호로 또 다른 정보를 동시에 나타내야 하는 애플리케이션이 있기 때문이다.

### 📚 특이한 동등 비교

- ES6부터는 `NaN`과 `0`, `-0`간의 동등 비교에 대한 잡다한 예외를 걱정하지 않아도 두 값이 절대적으로 동등한지를 확인하는 새로운 유틸리티를 지원하는데 `Object.is()`를 사용할 수 있다.

```javascript
var a = 2 / 'foo';
var b = -3 * 0;

Object.is(a, NaN); // true
Object.is(b, -0); // true
Object.is(b, 0); //false
```

- `==`나 `===`가 안전하다면 굳이 `Object.is()`는 사용하지 않는 편이 좋다.
- 기본 연산자가 좀 더 효울에 좋고 일반적이기 때문이다.
- `Object.is()`는 주로 특이한 동등 비교에 쓴다.

## 🎯 값 vs 레퍼런스
- 자바스크립트는 우선 어떤 변수가 다른 변수를 참조할 수 없다.
- 자바스크립트에서 레퍼런스는 값을 가리키므로 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 **항상 공유된 단일 값을 개별적으로 참조한다.**
- 자바스크립트에는 값 또는 레퍼런스의 할당 및 전달을 제어하는 구문 암시(Syntacic Hint)가 전혀 없다.
- 대신, 값의 타입만으로 값-복사, 레퍼런스-복사 둘 중 한쪽이 결정된다.

```javascript
var a = 2;
var b = a; // b는 언제나 a에서 값을 복사한다.
b++;
a; // 2
b; // 3

var c = [1, 2, 3];
var d = c; // d는 공유된 [1, 2, 3]값의 레퍼런스다.
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]
```
- `null`, `undefined`, `string`, `number`, `boolean` 그리고 ES6의 `symbol` 같은 단순 한(원시 값)은 언제나 **값-복사 방식으로 할당/전달된다.**
- 객체나 함수 등 합성 값은 **할당/전달시 반드시 레퍼런스 사본을 생성한다.**
- 위 예제 코드에서 a에는 2라는 초기 사본이 들어가고, b에는 또 다른 사본이 자리를 잡는다. 따라서 b를 바꿈으로써 a까지 동시에 값을 변경할 방법은 없다.
- 하지만, c와 d는 모두 **합성 값이자 동일한 공유 값 `[1,2,3]`에 대한 개별 레퍼런스다.**
- 여기서 기억해야 할 점은 c와 d가 `[1,2,3]`을 소유하는 것이 아니라 단지 **이 값을 동등하게 참조만 한다는 사실이다.**
- 따라서 레퍼런스로 실제 공유한 배열 값이 변경되면, 이 공유 값 한 군데만 영향을 미치므로 두 레퍼런스는 갱신된 값 `[1,2,3,4]`를 동시에 바라보게 된다.
- 레퍼런스는 변수가 아닌 값 자체를 가리키므로 A 레퍼런스로 B 레퍼런스가 가리키는 대상을 변경할 수는 없다.

```javascript
var a = [1,2,3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]

// 그 후
b = [4,5,6];
a; // [1,2,3]
b; // [4,5,6]
```

- `b = [4,5,6]`으로 할당해도 a가 참조하는 `[1,2,3]`은 영향을 받지 않는다.
- 그렇게 되려면 b가 배열을 가리키는 레퍼런스가 아닌 포인터가 되어야 하는데, 다시 말하지만 **자바스크립트에 포인터는 없다.**
- 다음 예제는 함수 인자이다.

```javascript
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  // 그 후
  x = [4,5,6];
  x.push(7);
  x; // [4,5,6,7]
}

var a = [1,2,3];
foo(a);
a; // [1,2,3,4]
```

- a를 인자로 넘기면 a의 레퍼런스 사본이 x에 할당된다. x와 a는 모두 **동일한 `[1,2,3]` 값을 가리키는 별도의 레퍼런스다.**
- 함수 내부에서 이 레퍼런스를 이용하여 값 자체를 변경하지만, 그 후 `x = [4,5,6]`으로 새 값을 할당해도 초기 레퍼런스 a가 참조하고 있던 값에는 아무런 영향이 없다.
- 즉, a 레퍼런스는 여전히 `[1,2,3,4]` 값을 바라보고 있다.
- 레퍼런스 x로 a가 가리키고 있는 값을 바꿀 도리는 없다. 다만 a와 x 둘 다 가리키는 **공유 값의 내용만 바꿀 수 있다.**
- **배열을 새로 생성하여 할당하는 식으로는 a의 내용을 `[4,5,6,7]`로 바꿀 수 없다.**
- **기존에 존재하는 배열 값만 변경해야 한다.**

```javascript
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  // 그 후
  x.length = 0; // 기존 배열을 즉시 비운다.
  x.push(4,5,6,7);
  x; // [4,5,6,7]
}

var a = [1,2,3];

foo(a);
a; // [4,5,6,7]
```

- `x.length = 0; x.push(4,5,6,7);`은 새 배열을 생성하는 코드가 아니라, 이미 **두 변수가 공유한 배열을 변경하는 코드**이므로 a는 새로운 값 [4,5,6,7]을 가리킨다.
- 합성 값을 값-복사에 의해 효과적으로 전달하려면 손수 **값의 사본을 만들어 전달한 레퍼런수가 원본을 가리키지 않게 하면 된다.**

```javascript
foo(a.slice());
```

- 인자 없이 `slice()`를 호출하면 **전혀 새로운 배열의 (얕은 복사에 의한) 사본을 만든다.**
- 이렇게 복사한 사본만을 가리키는 레퍼런스를 전달하니 `foo()`는 a의 내용을 건드릴 수 없다.
- 반대로 스칼라 원시 값을 레퍼런스처럼 바뀐 값이 바로바로 반영되도록 넘기려면 **원시 값을 다른 합성 값(객체, 배열 등)으로 감싸야한다.**

```javascript
function foo(wrapper) {
  wrapper.a = 42;
}

var obj = {
  a: 2
};
foo(obj);
obj.a; // 42
```

- `obj`는 스칼라 원시 프로퍼티 a를 감싼 래퍼(Wrapper)로 `foo()` 함수에 `obj` 레퍼런스 사본이 전달되고 래퍼 인자의 값을 바꾼다.
- 이제 래퍼 레퍼런스로 공유된 객체에 접근하여 프로퍼티를 수정할 수 있다.
- 같은 원리로 2와 같은 스칼라 원시 값을 레퍼런스 형태로 넘기려면 **`Number` 객체 레퍼로 원시 값을 박싱하면 된다.**
- `Number` 객체의 레퍼런스 사본이 함수에 전달되는 것은 맞지만 **공유된 객체를 가리키는 레퍼런스가 있다고 자동으로 공유된 원시 값을 변경할 권한이 주어지는 것은 아니다.**

```javascript
function foo(x) {
  x = x + 1;
  x; // 3
}

var a = 2;
var b = new Number(a); // Object(a)도 같은 표현이다.

foo(b); // 2
```

- 위의 문제는 **내부의 스칼라 원시 값이 불변이란 점이다.**(문자열, 불리언 포함)
- 스칼라 원시 값 2를 가진 `Number` 객체가 있다면, 이와 동일한 객체가 **다른 원시 값을 가지도록 변경할 수 없다.**
- 단지 **다른 값을 넣은**, 완전히 별개의 `Number`객체를 생성할 수는 있다.
- 표현식 `x + 1`에서 `x`가 사용될 내부에 간직된 스칼라 원시 값 2 는 **`Number`객체에서 자동 언박싱되므로** `x = x + 1`의 `x`는 공유된 레퍼런스에서 `Number` 객체로 교묘하게 뒤바뀌고 `2 + 1` 덧셈 결과인 스칼라 원시 값 3을 갖게 된다.
- 따라서 b는 원시 값 2를 씌운, 변경되지 않은/불변의 원본 `Number`객체를 참조한다.
- 하지만, 이렇게 객체 레퍼 `Number`를 사용하기보단 차라리 처음부터 손수 객체 레퍼(obj)를 쓰는 편이 훨씬 낫다.

## 🎯 정리하기
- 자바스크립트 배열은 **모든 타입의 값들을 숫자로 인덱싱한 집합**이다.
- 문자열은 일종의 유사 배열이지만, 나름 특성이 있기 때문에 배열로 다루고자 할 때는 조심해야 된다.
- 자바스크립트 숫자는 정수와 부동 소수점 숫자를 모두 포함한다.
- `null` 타입은 `null`이라는 값 하나뿐이고, 마찬가지로 `undefined` 타입도 값은 `undefined` 뿐이다.
- `undefined`는 할당된 값이 없다면 **모든 변수/프로퍼티의 디폴드 값이다.**
- `void` 연산자는 어떤 값이라도 `undefined`로 만들어 버린다.
- 숫자에는 `NaN`, `+Infinity`, `-Infinity`, `-0`과 같은 특수 값이 있다.
- 단순 스칼라 원시 값(문자열, 숫자 등)은 **값-복사**에 의해, 합성 값(객체 등)은 **레퍼런스-복사**에 의해 **값이 할당/전달**된다.
- 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 **오직 자신의 값**만 가리킨다.
