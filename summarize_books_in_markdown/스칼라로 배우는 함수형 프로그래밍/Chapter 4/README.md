# ğŸ­ Chapter 4: ì˜ˆì™¸ë¥¼ ì´ìš©í•˜ì§€ ì•Šì€ ì˜¤ë¥˜ ì²˜ë¦¬

ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ê²ƒì´ í•˜ë‚˜ì˜ ë¶€ìˆ˜ íš¨ê³¼ì„ì„ ê°„ë‹¨íˆ ì–¸ê¸‰í–ˆë‹¤. ì‹¤íŒ¨ ìƒí™©ê³¼ ì˜ˆì™¸ë¥¼ ë³´í†µì˜ ê°’ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìœ¼ë©°, ì¼ë°˜ì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬, ë³µêµ¬ íŒ¨í„´ì„ ì¶”ìƒí™”í™˜ ê³ ì°¨ í•¨ìˆ˜ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. ì˜¤ë¥˜ë¥¼ ê°’ìœ¼ë¡œì„œ ëŒë ¤ì¤€ë‹¤ëŠ” í•¨ìˆ˜ì  í•´ë²•ì€ ë” ì•ˆì „í•˜ê³  ì°¸ì¡° íˆ¬ëª…ì„±ì„ ìœ ì§€í•œë‹¤ëŠ” ì¥ì ì´ ìˆë‹¤. ê³„ë‹¤ê°€ ê³ ì°¨ í•¨ìˆ˜ ë•ë¶„ì— ì˜ˆì™¸ì˜ ì£¼ëœ ì´ì ì¸ **ì˜¤ë¥˜ ì²˜ë¦¬ ë…¼ë¼ì˜ í†µí•©**ë„ ìœ ì§€ëœë‹¤.

## ğŸƒ ì˜ˆì™¸ì˜ ì¥ë‹¨ì 
ì˜ˆì™¸ê°€ ì™œ ì°¸ì¡° íˆ¬ëª…ì„±ì„ í•´ì¹ ê¹Œ? ê·¸ë¦¬ê³  ê·¸ê²ƒì´ ì™œ ë¬¸ì œê°€ ë ê¹Œ?

```scala
// ì˜ˆì™¸ë¥¼ ë˜ì§€ê³  ë°›ê¸°
def failingFn(i: Int): Int = {
  val y: Int = throw new Exception("fail!")
  try {
    val x = 42 + 5
    x + y
  }
  catch { case e: Exception => 43 }
}

// ì˜ˆìƒëŒ€ë¡œ ì˜¤ë¥˜ ë°œìƒ
```

`y`ê°€ ì°¸ì¡°ì— íˆ¬ëª…í•˜ì§€ ì•ŠìŒì„ ì¦ëª…í•  ìˆ˜ ìˆë‹¤. ì„ì˜ì˜ ì°¸ì¡° íˆ¬ëª… í‘œí˜„ì‹ì„ ê·¸ê²ƒì´ ì§€ì¹­í•˜ëŠ” ê°’ìœ¼ë¡œ ì¹˜í™˜í•´ë„ í”„ë¡œê·¸ë¨ì˜ ì˜ë¯¸ê°€ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì„ ê¸°ì–µí•  ê²ƒì´ë‹¤. ë§Œì¼ `x + y`ì˜ `y`ë¥¼ `throw new Exception("fail!")`ë¡œ ì¹˜í™˜í•˜ë©´ ê·¸ì „ê³¼ëŠ” ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¨ë‹¤. ì´ì œëŠ” ì˜ˆì™¸ë¥¼ ì¡ì•„ì„œ 43ì„ ëŒë ¤ì£¼ëŠ” `try` ë¸”ë¡ ì•ˆì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ê¸° ë–„ë¬¸ì´ë‹¤.

```scala
def failingFn2(i: Int): Int = {
  try {
    val x = 42 + 5
    x + ((throw new Exception("fail!")): Int)
  }
  catch { case e: Exception => 43 }
}

// 43
```

ì°¸ì¡° íˆ¬ëª…ì„±ì´ë¼ëŠ” ê²ƒì„, ì°¸ì¡°ì— íˆ¬ëª…í•œ í‘œí˜„ì‹ì˜ ì˜ë¯¸ëŠ” **ë¬¸ë§¥(context)ì— ì˜ì¡´í•˜ì§€ ì•Šìœ¼ë©°** ì§€ì—­ì ìœ¼ë¡œ ì¶”ë¡ í•  ìˆ˜ ìˆì§€ë§Œ ì°¸ì¡°ì— íˆ¬ëª…í•˜ì§€ ì•Šì€ í‘œí˜„ì‹ì˜ ì˜ë¯¸ëŠ” **ë¬¸ë§¥ì— ì˜ì¡´ì **ì´ê³  ì¢€ ë” ì „ì—­ì˜ ì¶”ë¡ ì´ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒìœ¼ë¡œ ì´í•´í•´ë„ ë  ê²ƒì´ë‹¤.   

ì˜ˆì™¸ì˜ ì£¼ëœ ë¬¸ì œ ë‘ ê°€ì§€ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
- ë°©ê¸ˆ ë…¼ì˜í–ˆë“¯ì´, **ì˜ˆì™¸ëŠ” ì°¸ì¡° íˆ¬ëª…ì„±ì„ ìœ„ë°˜í•˜ê³  ë¬¸ë§¥ ì˜ì¡´ì„±ì„ ë„ì…í•œë‹¤.** ë”°ë¼ì„œ ì¹˜í™˜ ëª¨í˜•ì˜ ê°„ë‹¨í•œ ì¶”ë¡ ì´ ë¶ˆê°€ëŠ¥í•´ì§€ê³  ì˜ˆì™¸ì— ê¸°ì´ˆí•œ í˜¼ë€ìŠ¤ëŸ¬ìš´ ì½”ë“œê°€ ë§Œë“¤ì–´ì§„ë‹¤. ì´ê²ƒì´ ì˜ˆì™¸ë¥¼ ì˜¤ë¥˜ ì²˜ë¦¬ì—ë§Œ ì‚¬ìš©í•˜ê³  íë¦„ì˜ ì œì–´ì—ëŠ” ì‚¬ìš©í•˜ì§€ ë§ì•„ì•¼ í•œë‹¤ëŠ” ì†ì„¤ì˜ ê·¼ì›ì´ë‹¤.
- **ì˜ˆì™¸ëŠ” í˜•ì‹ì— ì•ˆì „í•˜ì§€ ì•Šë‹¤.** `failingFn`ì˜ í˜•ì‹ì¸ `Int => Int`ë§Œ ë³´ê³ ëŠ” ì´ í•¨ìˆ˜ê°€ ì˜ˆì˜¤ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ ì „í˜€ ì•Œ ìˆ˜ ì—†ìœ¼ë©°, ê·¸ë˜ì„œ ì»´íŒŒì¼ëŸ¬ëŠ” `failingFn`ì˜ í˜¸ì¶œìì—ê²Œ ê·¸ ì˜ˆì™¸ë“¤ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹ì„ ê²°ì •í•˜ë¼ê³  ê°•ì œí•  ìˆ˜ ì—†ë‹¤.

ì´ëŸ° ë‹¨ì ë“¤ì´ ì—†ìœ¼ë©´ì„œë„ ì˜ˆì™¸ì˜ ê°€ì¥ ì¥ì ì¸ **ì˜¤ë¥˜ ì²˜ë¦¬ ë…¼ë¦¬ì˜ í†µí•©ê³¼ ì¤‘ì•™ì§‘ì¤‘í™”**ë¥¼ ìœ ì§€í•˜ëŠ” ëŒ€ì•ˆì´ ìˆìœ¼ë©´ ì¢‹ì„ ê²ƒì´ë‹¤. ì§€ê¸ˆë¶€í„° ì†Œê°œí•˜ëŠ” ëŒ€ì•ˆ ê¸°ë²•ì€ "ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ëŒ€ì‹ , ì˜ˆì™¸ì ì¸ ì¡°ê±´ì„ ë°œìƒí–ˆìŒì„ ëœ»í•˜ëŠ” ê°’ì„ ëŒë ¤ì¤€ë‹¤"ë¼ëŠ” ì˜¤ë˜ëœ ì°©ì•ˆì— ê¸°ì´ˆí•œë‹¤. ë‹¨, ì´ ê¸°ë²•ì—ì„œëŠ” ì˜¤ë¥˜ ë¶€í˜¸ë¥¼ ì§ì ‘ ëŒë ¤ì£¼ëŠ” ëŒ€ì‹  ê·¸ëŸ° 'ë¯¸ë¦¬ ì •ì˜í•´ ë‘˜ ìˆ˜ ìˆëŠ” ê°’ë“¤'ì„ ëŒ€í‘œí•˜ëŠ” ìƒˆë¡œìš´ ì¼ë°˜ì  í˜•ì‹ì„ ë„ì…í•˜ê³ , ì˜¤ë¥˜ì˜ ì²˜ë¦¬ì™€ ì „íŒŒì— ê´€í•œ ê³µí†µì ì¸ íŒ¨í„´ë“¤ì„ ê³ ì°¨ í•¨ìˆ˜ë“¤ì„ ì´ìš©í•´ì„œ ìº¡ìŠí™”í•œë‹¤. ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ ì „ëµì€ **í˜•ì‹ì— ì™„ì „íˆ ì•ˆì „í•˜ë©°,** ìµœì†Œí•œì˜ êµ¬ë¬¸ì  ì¡ìŒìœ¼ë¡œë„ ìŠ¤ì¹¼ë¼ì˜ í˜•ì‹ ì ê²€ê¸°ë¥¼ ë„ì›€ì„ ë°›ì•„ì„œ ì‹¤ìˆ˜ë¥¼ ë¯¸ë¦¬ ë°œê²¬í•  ìˆ˜ ìˆë‹¤.

## ğŸƒ ì˜ˆì™¸ì˜ ê°€ëŠ¥í•œ ëŒ€ì•ˆë“¤
ì˜ˆì™¸ ëŒ€ì‹  ì‚¬ìš©í•  ë§Œí•œ ì—¬ëŸ¬ ê°€ì§€ ì ‘ê·¼ë°©ì‹ì„ ì¡°ì‚¬í•´ë³´ì. ë‹¤ìŒì€ ëª©ë¡ì˜ í‰ê· ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. ë¹ˆ ëª©ë¡ì— ëŒ€í•´ì„œëŠ” í‰ê· ì´ ì •ì˜ë˜ì§€ ì•ŠëŠ”ë‹¤.

```scala
def mean(xs: Seq[Double]): Double = 
  if (xs.isEmpty)
    throw new ArithmeticException("mean of empty list!")
  else xs.sum / xs.length
```

`mean`ì— ëŒ€í•´ ì˜ˆì™¸ ëŒ€ì‹  ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëŒ€ì•ˆ ëª‡ ê°€ì§€ë¥¼ ì‚´í´ë³´ì.   

ì²« ë²ˆì§¸ ëŒ€ì•ˆì€ `Double` í˜•ì‹ì˜ ê°€ì§œ ê°’ì„ ëŒë ¤ì£¼ëŠ” ê²ƒì´ë‹¤. ëª¨ë“  ê²½ìš°ì— ê·¸ëƒ¥ `xs.sum / xs.length`ë¥¼ ëŒë ¤ì¤€ë‹¤ë©´ ë¹ˆ ëª©ë¡ì— ëŒ€í•´ì„œëŠ” `0.0 / 0.0`ì„ ëŒë ¤ì£¼ê²Œ ë˜ëŠ”ë°, ì´ëŠ” `Double.NaN`ì´ë‹¤. ì•„ë‹ˆë©´ ë‹¤ë¥¸ ì–´ë–¤ ê²½ê³„ ê°’ì„ ëŒë ¤ì¤„ ìˆ˜ë„ ìˆê² ë‹¤. ìƒí™©ì— ë”°ë¼ì„œëŠ” ì›í•˜ëŠ” í˜•ì‹ì˜ ê°’ ëŒ€ì‹  `null`ì„ ëŒë ¤ì¤„ ìˆ˜ë„ ìˆë‹¤. ì´ëŸ° ë¶€ë¥˜ì˜ ì ‘ê·¼ë°©ì‹ì€ ì˜ˆì™¸ ê¸°ëŠ¥ì´ ì—†ëŠ” ì–¸ì–´ì—ì„œ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë° í”íˆ ì“°ì¸ë‹¤. ê·¸ëŸ¬ë‚˜ ì´ ì±…ì—ì„œëŠ” ì´ëŸ° ì ‘ê·¼ë°©ì‹ì„ ê±°ë¶€í•œë‹¤. ì´ìœ ëŠ” ì—¬ëŸ¬ ê°€ì§€ì´ë‹¤.
- ì˜¤ë¥˜ê°€ ì†Œë¦¬ ì—†ì´ ì „íŒŒë  ìˆ˜ ìˆë‹¤.
- ì‹¤ìˆ˜ì˜ ì—¬ì§€ê°€ ë§ë‹¤ëŠ” ì  ì™¸ì—, í˜¸ì¶œí•˜ëŠ” ìª½ì— í˜¸ì¶œìê°€ 'ì§„ì§œ' ê²°ê³¼ë¥¼ ë°›ì•˜ëŠ”ì§€ ì ê²€í•˜ëŠ” ëª…ì‹œì  `if`ë¬¸ë“¤ë¡œ êµ¬ì„±ëœ íŒì— ë°•íŒ ì½”ë“œê°€ ìƒë‹¹íˆ ëŠ˜ì–´ë‚œë‹¤.
- ë‹¤í˜•ì  ì½”ë“œì—ëŠ” ì ìš©í•  ìˆ˜ ì—†ë‹¤. ì¶œë ¥ í˜•ì‹ì— ë”°ë¼ì„œëŠ” ê·¸ í˜•ì‹ì˜ ê²½ê³„ ê°’ì„ ê²°ì •í•˜ëŠ” ê²ƒì´ **ë¶ˆê°€ëŠ¥**í•  ìˆ˜ë„ ìˆë‹¤.
- í˜¸ì¶œìì—ê²Œ íŠ¹ë³„í•œ ë°©ì¹¨ì´ë‚˜ í˜¸ì¶œ ê·œì•½ì„ ìš”êµ¬í•œë‹¤. `mean` í•¨ìˆ˜ë¥¼ ì œëŒ€ë¡œ ì‚¬ìš©í•˜ë ¤ë©´ í˜¸ì¶œìê°€ ê·¸ëƒ¥ `mean`ì„ í˜¸ì¶œí•´ì„œ ê·¸ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ì´ìƒì˜ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•œë‹¤. í•¨ìˆ˜ì— ì´ëŸ° íŠ¹ë³„í•œ ë°©ì¹¨ì„ ë¶€ì—¬í•˜ë©´, ëª¨ë“  ì¸ìˆ˜ë¥¼ ê· ì¼í•œ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜ì— ì „ë‹¬í•˜ê¸° ì–´ë ¤ì›Œì§„ë‹¤.

ë˜ ë‹¤ë¥¸ ëŒ€ì•ˆì€ í•¨ìˆ˜ê°€ ì…ë ¥ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ëŠ” ìƒí™©ì— ì²˜í–ˆì„ ë•Œ ë¬´ì—‡ì„ í•´ì•¼ í•˜ëŠ”ì§€ ë§í•´ì£¼ëŠ” ì¸ìˆ˜ë¥¼ í˜¸ì¶œìê°€ ì§€ì •í•˜ëŠ” ê²ƒì´ë‹¤.

```scala
def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double = 
  if (xs.isEmpty) onEmpty
  else xs.sum / xs.length
```

ì´ë ‡ê²Œ í•˜ë©´ `mean`ì€ ë¶€ë¶„ í•¨ìˆ˜ê°€ ì•„ë‹Œ ì™„ì „ í•¨ìˆ˜ê°€ ëœë‹¤. ê·¸ëŸ¬ë‚˜ ì—¬ê¸°ì—ëŠ” ê²°ê³¼ê°€ ì •ì˜ë˜ì§€ ì•Šì€ ê²½ìš°ì˜ ì²˜ë¦¬ ë°©ì‹ì„ í•¨ìˆ˜ì˜ **ì§ì ‘ì ì¸** í˜¸ì¶œìê°€ ì•Œê³  ìˆì–´ì•¼ í•˜ê³  ê·¸ëŸ° ê²½ìš°ì—ë„ í•­ìƒ í•˜ë‚˜ì˜ `Double` ê°’ì„ ëŒë ¤ì£¼ì–´ì•¼ í•œë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤.   

ìš°ë¦¬ì—ê²Œ í•„ìš”í•œ ê²ƒì€, ì •ì˜ë˜ì§€ ì•Šì€ ê²½ìš°ê°€ ê°€ì¥ ì ë‹¹í•œ ìˆ˜ì¤€ì—ì„œ ì²˜ë¦¬ë˜ë„ë¡ ê·¸ ì²˜ë¦¬ ë°©ì‹ì˜ ê²°ì •ì„ ë¯¸ë£° ìˆ˜ ìˆê²Œ í•˜ëŠ” ë°©ë²•ì´ë‹¤.

## ğŸƒ Option ìë£Œ í˜•ì‹
í•´ë²•ì€, í•¨ìˆ˜ê°€ í•­ìƒ ë‹µì„ ë‚´ì§€ ëª»í•œë‹¤ëŠ” ì ì„ ë°˜í™˜ í˜•ì‹ì„ í†µí•´ì„œ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒì´ë‹¤. ì´ë¥¼, ì˜¤ë¥˜ ì²˜ë¦¬ ì „ëµì„ í˜¸ì¶œìì—ê²Œ ë¯¸ë£¨ëŠ” ê²ƒìœ¼ë¡œ ìƒê°í•´ë„ ëœë‹¤. ì´ë¥¼ ìœ„í•´ `Option`ì´ë¼ëŠ” ìƒˆë¡œìš´ í˜•ì‹ì„ ë„ì…í•œë‹¤.

```scala
sealed trait Option[+A]
case class Some[+A](get: A) extends Option[A]
case object None extends Option[Nothing]
```

`Option`ì—ëŠ” ë‘ ê°œì˜ ê²½ìš° ë¬¸ì´ ìˆë‹¤. `Option`ì„ ì •ì˜í•  ìˆ˜ ìˆëŠ” ê²½ìš°ì—ëŠ” `Some`ì´ ë˜ê³ , ì •ì˜í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ëŠ” `None`ì´ ëœë‹¤.   

ì´ì œ `Option`ì„ ì´ìš©í•´ì„œ `mean`ì„ êµ¬í˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ëœë‹¤.

```scala
def mean(xs: Seq[Double]): Option[Double] =
  if (xs.isEmpty) None
  else Some(xs.sum / xs.length)
```

ì´ì œëŠ” ì´ í•¨ìˆ˜ì˜ ê²°ê³¼ê°€ í•­ìƒ ì •ì˜ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì‚¬ì‹¤ì´ í•¨ìˆ˜ì˜ ë°˜í™˜ ë°©ì‹ì— ë°˜ì˜ë˜ì–´ ìˆë‹¤. í•¨ìˆ˜ê°€ í•­ìƒ ì„ ì–¸ëœ ë°˜í™˜ í˜•ì‹ì˜ ê²°ê³¼ë¥¼ ëŒë ¤ì£¼ì–´ì•¼ í•œë‹¤ëŠ” ì ì€ ì—¬ì „í•˜ë¯€ë¡œ, `mean`ì€ ì´ì œ í•˜ë‚˜ì˜ **ì™„ì „ í•¨ìˆ˜**ì´ë‹¤. ì´ í•¨ìˆ˜ëŠ” ì…ë ¥ í˜•ì‹ì˜ ëª¨ë“  ê°’ì— ëŒ€í•´ ì •í™•íˆ í•˜ë‚˜ì˜ ì¶œë ¥ í˜•ì‹ ê°’ì„ ëŒë ¤ì¤€ë‹¤.

### ğŸˆ Optionì˜ ì‚¬ìš© íŒ¨í„´
ë¶€ë¶„ í•¨ìˆ˜ëŠ” í”„ë¡œê·¸ë˜ë°ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆìœ¼ë©°, FPì—ì„œëŠ” ê·¸ëŸ° ë¶€ë¶„ì„±ì„ í”íˆ `Option` ê°™ì€ ìë£Œ í˜•ì‹ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.   

`Option`ì´ í¸ë¦¬í•œ ì´ìœ ëŠ”, ì˜¤ë¥˜ ì²˜ë¦¬ì˜ ê³µí†µ íŒ¨í„´ì„ ê³ ì°¨ í•¨ìˆ˜ë“¤ì„ ì´ìš©í•´ì„œ ì¶”ì¶œí•¨ìœ¼ë¡œì¨ ì˜ˆì™¸ ì²˜ë¦¬ ì½”ë“œì— í”íˆ ìˆ˜ë°˜ë˜ëŠ” íŒì— ë°•íŒ ì½”ë“œë¥¼ ì‘ì„±í•˜ì§€ ì•Šì•„ë„ ëœë‹¤ëŠ” ì ì´ë‹¤.   

#### Optionì— ëŒ€í•œ ê¸°ë³¸ì ì¸ í•¨ìˆ˜ë“¤
`Option`ì€ ìµœëŒ€ í•˜ë‚˜ì˜ ì›ì†Œë¥¼ ë‹´ì„ ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì œì™¸í•˜ë©´ `List`ì™€ ë¹„ìŠ·í•˜ë‹¤.   

```scala
// Option ìë£Œ í˜•ì‹
trait Option[+A] {
  // ë§Œì¼ Optionì´ Noneì´ ì•„ë‹ˆë©´ fë¥¼ ì ìš©
  def map[B](f: A => B): Option[B]
  // ë§Œì¼ Optionì´ Noneì´ ì•„ë‹ˆë©´ f(ì‹¤íŒ¨í•  ìˆ˜ ìˆìŒ)ë¥¼ ì ìš©í•œë‹¤.
  def flatMap[B](f: A => Option[B]): Option[B]
  // B >: AëŠ” B í˜•ì‹ ë§¤ê°œë³€ìˆ˜ê°€ ë°˜ë“œì‹œ Aì˜ ìƒìœ„í˜•ì‹ì´ì–´ì•¼ í•¨ì„ ì˜ë¯¸í•œë‹¤.
  def getOrElse[B >: A](default: => B): B
  // obëŠ” í•„ìš”í•œ ê²½ìš°ì—ë§Œ í‰ê°€í•œë‹¤.
  def orElse[B >: A](ob: => Option[B]): Option[B]
  // ê°’ì´ fë¥¼ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ Someì„ Noneìœ¼ë¡œ ë³€í™˜í•œë‹¤.
  def filter(f: A => Boolean): Option[A]
}
```

#### ê¸°ë³¸ì ì¸ Option í•¨ìˆ˜ë“¤ì˜ ìš©ë¡€
í•˜ë‚˜ì˜ `Option`ì— ëŒ€í•´ ëª…ì‹œì ì¸ íŒ¨í„´ ë¶€í•¨ì„ ì ìš©í•  ìˆ˜ë„ ìˆì§€ë§Œ, ê±°ì˜ ëª¨ë“  ê²½ìš°ì— ìœ„ì— ë§í•œ ê³ ì°¨ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.   

`map` í•¨ìˆ˜ëŠ” `Option` ì•ˆì˜ ê²°ê³¼ë¥¼ ë³€í™˜í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•Šì•˜ë‹¤ëŠ” ê°€ì •í•˜ì—ì„œ ê³„ì‚°ì„ ì§„í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ìƒê°í•´ë„ ë  ê²ƒì´ë‹¤. ë˜í•œ, ì´ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ë‚˜ì¤‘ì˜ ì½”ë“œì— ë¯¸ë£¨ëŠ” ìˆ˜ë‹¨ì´ê¸°ë„ í•˜ë‹¤.

```scala
case class Employee(name: String, department: String)

def lookupByName(name: String): Option[Employee] = ...

val joeDepartment: Option[String] = 
  lookupByName("Joe").map(_.department)
```

ì´ ì˜ˆì—ì„œ `lookupByName("Joe")`ëŠ” `Option[Employee]`ë¥¼ ëŒë ¤ì¤€ë‹¤. ê·¸ê²ƒì„ `map`ìœ¼ë¡œ ë³€í™˜í•˜ë©´ `Joe`ê°€ ì†í•œ ë¶€ì„œì˜ ì´ë¦„ì„ ëœ»í•˜ëŠ” `Option[String]`ì´ ë‚˜ì˜¨ë‹¤. ì—¬ê¸°ì„œ `lookupBtName("Joe")`ì˜ ê²°ê³¼ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì ê²€í•˜ì§€ ì•ŠìŒì„ ì£¼ëª©í•˜ê¸° ë°”ë€ë‹¤. ê·¸ëƒ¥ ì˜¤ë¥˜ê°€ ì „í˜€ ë°œìƒí•˜ì§€ ì•Šì•˜ë‹¤ëŠ” ë“¯ì´ `map`ì˜ ì¸ìˆ˜ ì•ˆì—ì„œ ê³„ì‚°ì„ ê³„ì† ì§„í–‰í•œë‹¤. ë§Œì¼ `lockupByName("Joe")`ê°€ `None`ì„ ëŒë ¤ì£¼ì—ˆë‹¤ë©´ ê³„ì‚°ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì´ ì·¨ì†Œë˜ì–´ì„œ `map`ì€ `_.department` í•¨ìˆ˜ë¥¼ ì „í˜€ í˜¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤.   

`flatMap`ì„ ì´ìš©í•˜ë©´ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ ì´ë£¨ì–´ì§„ ê³„ì‚°ì„ ìˆ˜í–‰í•˜ë˜ ì–´ë–¤ ë‹¨ê³„ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ê·¸ ì¦‰ì‹œ ë‚˜ë¨¸ì§€ ëª¨ë“  ê³¼ì •ì´ ì·¨ì†Œë˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ì´ëŠ” `None.flatMap(f)`ê°€ `f`ë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šê³  ì¦‰ì‹œ `None`ì„ ëŒë ¤ì£¼ê¸° ë•Œë¬¸ì´ë‹¤.   

`filter`ëŠ” ì„±ê³µì ì¸ ê°’ì´ ì£¼ì–´ì§„ ìˆ ì–´ì™€ ë¶€í•©í•˜ì§€ ì•Šì„ ë•Œ ì„±ê³µì„ ì‹¤íŒ¨ë¡œ ë³€í™˜í•˜ëŠ”ë° ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. í”í•œ ì‚¬ìš© íŒ¨í„´ì€ `map`, `flatMap`, `filter`ì˜ ì„ì˜ì˜ ì¡°í•©ì„ ì´ìš©í•´ì„œ `Option`ì„ ë³€í™˜í•˜ê³  ì œì¼ ëì—ì„œ `getOrElse`ë¥¼ ì´ìš©í•´ì„œ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ë‹¤.

```scala
val dept: String =
  lookupByName("Joe").
  map(_.dept).
  filter(_ != "Accounting").
  getOrElse("Default Dept")
```

ì—¬ê¸°ì„œ `getOrElse`ëŠ” `Option[String]`ì„ `String`ìœ¼ë¡œ ë³€í™˜í•˜ë˜ `"Joe"`ë¼ëŠ” í‚¤ê°€ `Map`ì— ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ `Joe`ì˜ ë¶€ì„œê°€ `"Accounting"`ì¸ ê²½ìš°ì—ëŠ” ê¸°ë³¸ ë¶€ì„œ ì´ë¦„ì„ ëŒë ¤ì£¼ëŠ” ì—­í• ì„ í•œë‹¤.   

ì˜¤ë¥˜ë¥¼ ë³´í†µì˜ ê°’ìœ¼ë¡œ ëŒë ¤ì£¼ë©´ ì½”ë“œë¥¼ ì§œê¸°ê°€ í¸í•´ì§€ë©°, ê³ ì°¨ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ì˜ˆì™¸ì˜ ì£¼ëœ ì¥ì ì¸ ì˜¤ë¥˜ ì²˜ë¦¬ ë…¼ë¦¬ì˜ í†µí•©ê³¼ ê²©ë¦¬ë„ ìœ ì§€í•  ìˆ˜ ìˆë‹¤. ê³„ì‹¼ì˜ ë§¤ ë‹¨ê³„ë§ˆë‹¤ `None`ì„ ì ê²€í•  í•„ìš”ê°€ ì—†ìŒì„ ì£¼ëª©í•˜ê¸° ë°”ë€ë‹¤.

### ğŸˆ ì˜ˆì™¸ ì§€í–¥ì  APIì˜ Option í•©ì„±ê³¼ ìŠ¹ê¸‰, ê°ì‹¸ê¸°
ì¼ë‹¨ `Option`ì„ ì‚¬ìš©í•˜ê¸° ì‹œì‘í•˜ë©´ ì½”ë“œ ê¸°ë°˜ ì „ì²´ì— `Option`ì´ ë²ˆì§€ê²Œ ë˜ë¦¬ë¼ëŠ” ì„±ê¸‰í•œ ê²°ë¡ ì„ ë‚´ë¦¬ëŠ” ë…ìë„ ìˆì„ ê²ƒì´ë‹¤. ì¦‰, `Option`ì„ ë°›ê±°ë‚˜ ëŒë ¤ì£¼ëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ëª¨ë“  ì½”ë“œë¥¼ `Some`ì´ë‚˜ `None`ì„ ì²˜ë¦¬í•˜ë„ë¡ ìˆ˜ì •í•´ì•¼ í•œë‹¤ê³  ì¶”ì¸¡í•  ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ ì‹¤ì œë¡œëŠ” ê·¸ëŸ° ë¶€ë‹´ì„ ì§ˆ í•„ìš”ê°€ ì—†ë‹¤. ë³´í†µì˜ í•¨ìˆ˜ë¥¼ `Option`ì— ëŒ€í•´ ì‘ìš©í•˜ëŠ” í•¨ìˆ˜ë¡œ **ìŠ¹ê¸‰ì‹œí‚¬** ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

```scala
def lift[A, B](f: A => B): Option[A] => Option[B] = _ map f
```

ì´ëŸ¬í•œ `lift`ê°€ ìˆìœ¼ë©´ ì§€ê¸ˆê¹Œì§€ ë‚˜ì˜¨ ê·¸ ì–´ë–¤ í•¨ìˆ˜ë¼ë„ í•œ `Option` ê°’ì˜ **ë¬¸ë§¥ ì•ˆì—ì„œ** ì‘ìš©í•˜ë„ë¡ ë³€í™˜í•  ìˆ˜ ìˆë‹¤.

```scala
val abs0: Option[Double] => Option[Double] = lift(math.abs)
```

ìœ„ ì˜ˆì—ì„œ ë³´ë“¯ì´, ì„ íƒì  ê°’ì— ì‘ìš©í•˜ëŠ” `math.abs` í•¨ìˆ˜ë¥¼ ì§ì ‘ ì‘ì„±í•  í•„ìš”ê°€ ì—†ë‹¤. ê·¸ëƒ¥ ê·¸ í•¨ìˆ˜ë¥¼ `Option` ë¬¸ë§¥ìœ¼ë¡œ ìŠ¹ê²©ì‹œí‚¤ë©´ ëœë‹¤. ì´ëŸ¬í•œ ìŠ¹ê¸‰ì€ **ëª¨ë“ ** í•¨ìˆ˜ì— ê°€ëŠ¥í•˜ë‹¤.

## ğŸƒ Either ìë£Œ í˜•ì‹
`Option`ì´ ì˜ˆì™¸ì ì¸ ì¡°ê±´ì´ ë°œìƒí–ˆì„ ë•Œ ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ì§€ì— ëŒ€í•œ ì •ë³´ë¥¼ ì œê³µí•˜ì§€ ëª»í•œë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤. ì‹¤íŒ¨ ì‹œ ì´ í˜•ì‹ì€ ê·¸ëƒ¥ ìœ íš¨í•œ ê°’ì´ ì—†ìŒì„ ëœ»í•˜ëŠ” `None`ì„ ëŒë ¤ì¤„ ë¿ì´ë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ ì™¸ì˜ ê²ƒì´ í•„ìš”í•  ë•Œë„ ìˆë‹¤.   

ì‹¤íŒ¨ì— ê´€í•´ ì•Œê³  ì‹¶ì€ ì •ë³´ê°€ ì–´ë–¤ ê²ƒì´ë“  ê·¸ê²ƒì„ ë¶€í˜¸í™”í•˜ëŠ” ìë£Œ í˜•ì‹ì„ ë§Œë“œëŠ” ê²ƒì€ ë¬¼ë¡  ê°€ëŠ¥í•˜ë‹¤. ê·¸ëƒ¥ ì‹¤íŒ¨ê°€ ë°œìƒí–ˆìŒì„ ì•Œë©´ ì¶©ë¶„í•œ ë•Œì—ëŠ” `Option`ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤. ê·¸ ì™¸ì˜ ê²½ìš°ì—ëŠ” ì¢€ ë” ë§ì€ ì •ë³´ê°€ í•„ìš”í•˜ë‹¤.

```scala
sealed trait Either[+E, +A]
case class Left[+E](value: E) extends Either[E, Nothing]
case class Right[+A](value: A) extends Either[Nothing, A]
```

`Option` ì²˜ëŸ¼ `Either`ë„ `case`ê°€ ë‘ ê°œë¿ì´ë‹¤. `Option`ê³¼ì˜ ë³¸ì§ˆì ì¸ ì°¨ì´ëŠ”, ë‘ ê²½ìš° ëª¨ë‘ ê°’ì„ ê°€ì§„ë‹¤ëŠ” ê²ƒì´ë‹¤. ì•„ì£¼ ê°œê´„ì ìœ¼ë¡œ ë§í•˜ìë©´, `Either` ìë£Œ í˜•ì‹ì€ ë‘˜ ì¤‘ í•˜ë‚˜ì¼ ìˆ˜ ìˆëŠ” ê°’ë“¤ì„ ëŒ€í‘œí•œë‹¤. ì´ í˜•ì‹ì€ ë‘ í˜•ì‹ì˜ **ë¶„ë¦¬í•©ì§‘í•©**(ì„œë¡œ ì†Œ í•©ì§‘í•©)ì´ë¼ í•  ìˆ˜ ìˆë‹¤. ì´ í˜•ì‹ì„ ì„±ê³µ ë˜ëŠ” ì‹¤íŒ¨ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë° ì‚¬ìš©í•  ë•Œì—ëŠ”, `Right` ìƒì„±ìë¥¼ ì„±ê³µì„ ë‚˜íƒ€ë‚´ëŠ” ë° ì‚¬ìš©í•˜ê³ (ì˜¤ë¥¸ìª½ì´ ì˜³ì€ ìª½) `Left`ëŠ” ì‹¤íŒ¨ì— ì‚¬ìš©í•œë‹¤. ì™¼ìª½ í˜•ì‹ ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ìœ¼ë¡œëŠ” error(ì˜¤ë¥˜)ë¥¼ ì˜ë¯¸í•˜ëŠ” `E`ë¥¼ ì‚¬ìš©í•œë‹¤.   

ê·¸ëŸ¼ `mean` ì˜ˆì œë¥¼ ë‹¤ì‹œ ë³´ì. ì´ë²ˆì—ëŠ” ì‹¤íŒ¨ì˜ ê²½ìš°ì— `String`ì„ ëŒë ¤ì¤€ë‹¤.

```scala
def mean(xs: IndexedSeq[Double]): Either[String, Double] =
  if (xs.isEmpty)
    Left("mean of empty list!")
  else
    Right(xs.sum / xs.length)
```

ì˜¤ë¥˜ì— ëŒ€í•œ ì¶”ê°€ ì •ë³´, ì´ë¥¼í…Œë©´ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ìœ„ì¹˜ë¥¼ ì•Œ ìˆ˜ ìˆëŠ” ìŠ¤íƒ ì¶”ì  ì •ë³´ê°€ ìˆìœ¼ë©´ í¸ë¦¬í•œ ê²½ìš°ê°€ ì¢…ì¢… ìˆë‹¤. ê·¸ëŸ° ê²½ìš° `Either`ì˜ `Left`ìª½ì—ì„œ ê·¸ëƒ¥ ì˜ˆì™¸ë¥¼ ëŒë ¤ì£¼ë©´ ëœë‹¤.

```scala
def safeDiv(x: Int, y: Int): Either[Exception, Int] =
  try Right(x / y)
  catch { case e: Exception => Left(e) }
```

`Option`ì—ì„œ í–ˆë“¯ì´, ë˜ì ¸ì§„ ì˜ˆì™¸ë¥¼ ê°’ìœ¼ë¡œ ë³€í™˜í•œë‹¤ëŠ” ì´ëŸ¬í•œ ê³µí†µì˜ íŒ¨í„´ì„ ì¶”ì¶œí•œ í•¨ìˆ˜ `Try`ë¥¼ ì‘ì„±í•´ ë³´ì.

```scala
def Try[A](a: => A): Either[Exception, A] =
  try Right(a)
  catch { case e: Exception => Left(e) }
```

ì´ëŸ¬í•œ ì •ì˜ë“¤ì´ ìˆìœ¼ë©´ `Either`ë¥¼ `for-í•¨ì¶•`ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ì£¼ë¬™í•˜ì.

```scala
def parseInsuranceRateQuote(
  age: String,
  numberOfSpeedTickets: String
): Either[Exception. Double] =
  for {
    a <- Try { age.toInt }
    tickets <- Try { numberOfSpeedingTickets.toInt }
  } yield insuranceRateQuote(a, tickets)
```

ì´ì œëŠ” ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ `None`ì´ ì•„ë‹ˆë¼ ë°œìƒí•œ ì‹¤ì œ ì˜ˆì™¸ì— ëŒ€í•œ ì •ë³´ë¥¼ ì–»ê²Œ ë˜ì—ˆë‹¤.   

ë§ˆì§€ë§‰ ì˜ˆë¡œ, ë‹¤ìŒì€ `map2`ë¥¼ ì ìš©í•œ ì˜ˆë‹¤. í•¨ìˆ˜ `mkPerson`ì€ ì£¼ì–´ì§„ ì´ë¦„ê³¼ ë‚˜ì´ì˜ ìœ íš¨ì„±ì„ ì ê²€í•œ í›„ ìœ íš¨í•œ `Person`ì„ ìƒì„±í•œë‹¤.

```scala
// Eitherë¥¼ ìë£Œ ìœ íš¨ì„± ì ê²€ì— í™œìš©
case class Person(name: Name, age: Age)
sealed class Name(val value: String)
sealed class Age(val value: Int)

def mkName(name: String): Either[String, Name] =
  if (name == ""  || name == null) Left("Name is empty.")
  else Right(new Name(name))

def mkAge(age: Int): Either[String, Age] =
  if (age < 0) Left("Age is out of range.")
  else Right(new Age(age))

def mkPerson(name: String, age: Int): Either[String, Person] =
  mkName(name).map2(mkAge(age))(Person(_, _))
```
