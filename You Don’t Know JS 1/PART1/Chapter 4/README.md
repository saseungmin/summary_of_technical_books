## 🌈 Chapter 4 : 강제변환

### 🎯 값 변환

- 어떤 값을 다른 타입의 값으로 바꾸는 과정이 **명시적이면 타입 캐스팅(Type Casting)**, **암시적이면 강제변환(Coercion)** 이라고 한다.
- 항상 그렇지 안을 수도 있지만 자바스크립트에서 강제변환을 하면 문자열, 숫자, 불리언 같은 스칼라 원시 값 중 하나가 되며, 객체, 함수 같은 합성 값 타입으로 변환될 일은 없다.
- 이렇게도 구분할 수 있는데, 타입 캐스팅(타입 변환)은 **정적 타입 언어에서 컴파일 시점**에, 강제변환은 **동적 타입 언어에서 런타임 시점**에 발생한다.
- 그러나 자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컽는 경향이 있어서, 암시적 강제변환과 명시적 강제변환 두 가지로 구별할 수도 있다.
- 명시적 강제변환은 **의도적으로 타입변환을 일으킨다는 사실이 명백**한 반면, 암시적 강제변환은 **다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환**이다.

```javascript
var a = 42;
var b = a + ''; // 암시적 강제변환
var c = String(a); // 명시적 강제변환
```

- 둘의 차이는 엄밀히 말해 스타일의 차이뿐 아니라 작동상에도 미묘한 차이가 있다.
- 명시적(Explicit) : 암시적(Implicit) = 명백한(Obvious) : 숨겨진 부수 효과(Hidden Side Effect) 용어상으로는 이러한 대응 관계가 성립


### 🎯 추상 연산

#### 📚 ToString
- 문자열이 아닌 값 -> 문자열 변환 작업은 ES5 9.8의 `ToString` 추상 연산 로직이 담당한다.

```javascript
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

a; // 1.07e+21
a.toString(); // "1.07e+21"
```
- 일반 객체는 특별히 지정하지 않으면 기본적으로 `toString()` 메서드가 내부 `[[Class]]`를 반환한다.
- 자신의 `toString()` 메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 기본 호출되어 `toString()`을 대체한다.
- 배열은 기본적으로 재정의된 `toString()`이 있다. 문자열 변환 시 모든 원소 값이 콤마(.)로 분리된 형태로 이어진다.

```javascript
var a = [1, 2, 3];
a.toString(); // "1,2,3"
```
- 또한 `toString()` 메서드는 **명시적으로도 호출 가능**하며, 문자열 콘텍스트에서 **문자열 아닌 값이 있을 경우에도 자동 호출된다.**

**📌 JSON 문자열화**
- `ToString`은 `JSON.stringify()` 유틸리티를 사용하여 어떤 값을 `JSON` 문자열로 직렬화하는 문제와도 연관된다.
- `JSON` 문자열화는 강제변환과 똑같지는 않지만, `ToString` 규칙과 관련이 있다.
- 대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는, `JSON`문자열화나 `toString()` 변환이나 기본적으로 같은 로직이다.

```javascript
JSON.stringify(42); // "42"
JSON.stringify("42"); // ""42""
JSON.stringify(null); // "null"
JSON.stringify(true); // "true"
```

- `JSON` 안전 값(`JSON` 표현형으로 확실히 나타낼 수 있는 값)은 모두 `JSON.stringify()`로 문자열화할 수 있다.
- `JSON` 안전 값이 아닌 것들은 `undefined`, 함수, 심벌, 환형 참조 객체(프로퍼티 참조가 무한 순환되는 구조의 객체) 같은 것들이다.
- 만약 `JSON.stringify()`는 안전 값이 아닌 것들은 자동으로 누락시키며 만약 배열에 포함되어 있으면 `null`로 바꾼다. 객체 프로퍼티에 있으면 지워버린다.

```javascript
JSON.stringify(undefined); // undefined
JSON.stringify(function(){}); // undefined

JSON.stringify([1, undefined, function(){}, 4]); // "[1,null,null,4]"
JSON.stringify({ a:2, b: function(){} }) // "{"a":2}"
```

- 환형 참조 객체를 넘기면 에러가 발생한다.
- 객체 자체에 `toJSON()` 메서드가 정의되어 있다면 먼저 이 메서드를 호출하여 직렬화한 값을 반환한다.
- 부적절한 `JSON`값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 `toJSON()` 메서드를 따로 정의해야 한다.

```javascript
var o = {};
var a = {
  b: 42,
  c: o,
  d: function(){}
};

// a를 환형 참조 객체로 만든다.
o.e = a;

// 에러 발생
JSON.stringify(a); // Uncaught TypeError: Converting circular structure to JSON

// JSON 값으로 직렬화하는 함수를 따로 정의한다.
a.toJSON = function() {
  return { b: this.b }; // 직렬화에 b만 포함시킨다.
}

JSON.stringify(a); // "{"b":42}"
```

- `toJSON()`은 적절히 평범한 실제 값을 반환하고 문자열화 처리는 `JSON.stringify()`이 담당한다.
- 다시말해 `toJSON()`의 역할은 **문자열화하기 적당한 `JSON` 안전 값을 바꾸는 것**이지, `JSON` 문자열로 바꾸는 것이 아니다.

```javascript
var a = {
  val: [1, 2, 3],
  // 맞다
  toJSON: function() {
    return this.val.slice(1);
  }
};

var b = {
  val: [1, 2, 3],
  // 틀리다
  toJSON: function() {
    return '[' + this.val.slice(1).join() + ']';
  }
};

JSON.stringify(a); // "[2,3]"
JSON.stringify(b); // ""[2,3]""
```

- 배열 아니면 함수 형태의 대체자를 `JSON.stringify()`의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 필터링 하는 방법이 있다. `toJSON()`이 직렬화할 값을 준비하는 방식과 비슷하다.
- 대체자가 배열이면 **전체 원소는 문자열이어야 하고 각 원소는 객체 직렬화의 대상 프로퍼티명이다.** 즉, 여기에 포함되지 않은 프로퍼티는 직렬화 과정에서 빠진다.
- 대체자가 함수면 처음 한 번은 객체 자신에 대해, 그 다음엔 각 객체 프로퍼티별로 한 번씩 실행하면서 매번 키와 값 두 인자를 전달한다. 직렬화 과정에서 해당 키를 건너뛰려면 `undefined`를 그 외엔 해당 값을 반환한다.

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
};
JSON.stringify(a, ['b', 'c']); // "{"b":42,"c":"42"}"
JSON.stringify(a, function(k, v) {
  if(k !== 'c') return v;
}); // "{"b":42,"d":[1,2,3]}"
```

- 함수인 대체자는 최초 호출 시 키 인자 `k`는 `undefined`이다.
- 대체자는 `if` 문에서 키가 `c`인 프로퍼티를 솎아내고 문자열화는 재귀적으로 이루어지므로 배열 `[1,2,3]`의 각 원소는 `v`(1,2,3)로, 인덱스는 `k`(0,1,2)로 각각 대체자 함수에 전달된다.
- `JSON.stringify()`의 세 번째 선택 인자는 스페이스라고 하며 사람이 읽기 쉽도록 들여쓰기를 할 수 있다.
- 들여 쓰기를 할 빈 공간의 개수를 숫자로 지정하거나 문자열(10자 이상이면 앞에서 10자까지만 잘라 사용한다)을 지정하여 각 들여 쓰기 수준에 사용한다.

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
};

JSON.stringify(a, null, 3);
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       null,
//       3
//    ]
// }"
JSON.stringify(a, null, '-----');
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------null,
// ----------3
// -----]
// }"
```

- `JSON.stringify()`는 직접적인 강제변환의 형식은 아니지만 두 가지 이유로 `ToString` 강제변환과 연관된다.
  - 문자열, 숫자, 불리언, `null` 값이 `JSON`으로 문자열화하는 방식은 `ToString` 추상 연산의 규칙에 따라 문자열 값으로 강제변환되는 방식과 동일하다.
  - `JSON.stringify()`에 전달한 객체가 **자체 `toJSON()` 메서드를 갖고 있다면**, **문자열화 전 `toJSON()`이 자동 호출**되어 **`JSON` 안전 값으로 강제변환**된다.

#### 📚 ToNumber

- *숫자가 아닌 값 -> 수식 연산이 가능한 숫자* 변환 로직은 예를 들어 `true`는 1, `false`는 0이 되고, `undefined`는 `NaN`으로, `null`은 0으로 바뀐다.
- 문자열 값에 `ToNumber`를 적용하면 대부분 숫자 리터럴 규칙/구문과 비슷하게 작동한다.
- 변환이 실패하면 결과는 `NaN`이다.
- 한 가지 차이는 0이 앞에 붙은 8진수는 `ToNumber`에서 올바른 숫자 리터럴이라도 8진수로 처리하지 않는다.(10진수로 처리)
- 객체(또는 배열)는 **동등한 원시 값으로 변환 후** 그 결괏값(아직 숫자가 아닌 원시 값)을 앞서 설명한 `ToNumber` 규칙에 의해 강제변환한다.
- 동둥한 원시 값으로 바꾸기 위해 **`ToPrimitive` 추상 연산 과정에서 해당 객체가 `valueOf()` 메서드를 구현**했는지 확인한다.
- **`valueOf()`를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환**하되, 그렇지 않을 경우 (`toString()` 메서드가 존재하면) **`toString()`을 이용하여 강제변환**한다.
- 원시 값으로 **바꿀 수 없을 땐 `TypeError` 오류를 던진다.**
- ES5부터는 `[[Prototype]]`가 `null`인 경우 대부분 `Object.create(null)`를 이용하여 강제변환이 불가능한 객체(`valueOf()`, `toString()` 메서드가 없는 객체)를 생성할 수 있다.

```javascript
var a = {
  valueOf: function() {
    return '42';
  }
};

var b = {
  toString: function() {
    return '42';
  }
};

var c = [4, 2];
c.toString = function() {
  return this.join(''); // '42'
};

Number(a); // 42
Number(b); // 42
Number(c); // 42
Number(''); // 0
Number([]); // 0
Number(['abc']); // NaN
```

#### 📚 ToBoolean
- 1을 `true`로, 0을 `false`로 강제변환할 수는 있지만 그렇다고 두 값이 똑같은 건 아니다.

**📌 Falsy 값**
- `true/false`가 아닌 값을 불리언에 상당한 값으로 강제변환했을 때, 이 값들은?
- 자바스크립트 모든 값은 다음 둘 중 하나다.
  1. 불리언으로 강제변환하면 `false`가 되는 값
  2. 1번을 제외한 나머지(즉, 명백히 `true`인 값) 
- 명세가 정의한 `falsy` 값은 `undefined`, `null`, `false`, `+0`, `-0`, `NaN`, `''`이다.
- 위 `falsy` 값은 불리언으로 강제변환하면 `false`이다.
- 반대로 위 값들 중 없으면 `truthy`이다. 하지만 자바스크립트 명세에는 `truthy` 값 목록 같은 건 없다.
- 모든 객체는 명백히 `truthy`하다는 식의 몇 가지 예시만 있을 뿐 `falsy` 값 목록에 없으면 응당 `truthy` 값이 되는 것이다.

**📌 Falsy 객체**

```javascript
var a = new Boolean(false);
var b = new Number(0);
var c = new String('');

var d= Boolean(a && b && c);

d; // true
```
- a, b, c는 명백히 `falsy` 값을 감싼 객체이다.
- d가 `true`인 것으로 봐서 세 변수는 모두 `true`이다.
- 일반적인 자바스크립트의 의미뿐 아니라 브라우저만의 특이한 작동 방식을 가진 값을 생성하는 경우가 있는데, 이것이 바로 `falsy` 객체의 정체이다.
- `falsy` 객체는 불리언으로 강제변환하면 `false`이다.

**📌 truthy 값**

```javascript
var a = 'false';
var b = '0';
var c = "''";

var d = Boolean(a && b && c);

d; // true
```
- 문자열 값을 보면 `falsy`처럼 보이지만 문자열 값 자체는 모두 `truthy` 이기 때문이다.

```javascript
var a = []; // 빈 배열
var b = {}; // 빈 객체
var c = function(){}; // 빈 함수

var d = Boolean(a && b && c);
d; // true
```

- 외향은 `falsy` 처럼 생겼지만 어떻든 `[]`, `{}`, `function(){}`는 `falsy` 값 목록에 없으므로 모두 `truthy` 값이다.
- `truthy` 값 목록은 사실상 무한하여 일일이 작성하는 게 불가능하다.
- `truthy/falsy` 개념은 어떤 값을 불리언 타입으로 (명시적/암시적) 강제변환 시 해당 값의 작동 방식을 이해한다는 점에서 중요하다.

### 🎯 명시적 강제변환

- 명시적 강제변환(Explicit Coercion)은 분명하고 확실한 타입변환이다.

#### 📚 명시적 강제변환: 문자열 ↔ 숫자
- 문자열 ↔ 숫자 강제변환은 `String()`과 `Number()` 함수를 이용하는데, **앞에 `new` 키워드가 붙지 않기 때문에 객체 래퍼를 생성하는 것이 아니란 점이다.**

```javascript
var a = 42;
var b = String(a);

var c = '3.14';
var d = Number(c);

b; // '42'
d; // 3.14
```
- `ToString` 추상 연산 로직에 따라 `String()`은 **값을 받아 원시 문자열로 강제 변환**한다.
- `Number()` 역시 마찬가지로 `ToNumber` 추상 연산 로직에 의해 **어떤 값이든 원시 숫자 값으로 강제변환한다.**
- `String()`과 `Number()` 이외에도 문자열 ↔ 숫자의 명시적인 타입변환 방법은 또 있다.

```javascript
var a = 42;
var b = a.toString();

var c = '3.14';
var d = +c;

b; // '42'
d; // 3.14
```

- `a.toString()` 호출은 겉보기엔 명시적이지만, 몇 가지 암시적인 요소가 감춰져 있다.
- 원시 값 42에는 `toString()` 메서드가 없으므로 엔진은 `toString()`를 사용할 수 있게 자동으로 42를 객체 래퍼로 박싱한다. (말하자면 명시적으로, 암시적인 작동이다.)
- `+c`의 `+`는 단항연산자로 **피연산자 `c`를 숫자로, 명시적 강제변환한다.**

```javascript
var c = '3.14';
var d = 5+ +c;
d; // 8.14
```

- `-` 단항 연산자 역시 `+` 처럼 강제변환을 하지만 숫자의 부호를 뒤바꿀 수도 있다.

```javascript
1 + - + + + - + 1; // 2
```
- 명시적으로 변환하여 문제를 악화시키지 말고 혼동을 줄이는 게 좋다.

**📌 날짜 ➡ 숫자**
- `+` 단항 연산자는 `Date` 객체 ➡ 숫자 강제변환 용도로 쓰인다.
- 결괏값이 날짜/시각 값을 유닉스 타임스탬프 표현형이기 때문이다.

```javascript
var d = new Date();

+d; // 1604492699962

// 현재 시각을 타임스탬프로 바꿀 때 관용적으로 사용하는 방법
var timestamp = +new Date();
```

- 그러나 강제변환을 하지 않고도 `Date` 객체로부터 타임스탬프를 얻는 방법이 있다.
- 오히려 강제변환을 하지 않은 쪽이 더 명시적이므로 권장할 만하다.

```javascript
var timestamp = new Date().getTime();

// ES5에 추가된 정적 함수 Date.now()를 쓰는 게 더 낫다.
var timestamp = Date.now();
```

- 날짜 타입에 관한 한 강제변환은 권하지 않고 현재 타입스탬프는 `Date.now()`로, 그 외 특정 날짜/시간의 타임스탬프는 `new Date().getTime()`를 대신 사용하자.

**📌 이상한 나라의 틸드(~)**
- 앞에서 자바스크립트 비트 연산자는 오직 32비트 연산만 가능하다고 했다. 즉, 비트 연산을 하면 피연산자는 32 비트 값으로 강제로 맞춰지는데, ToInt32 추상 연산이 이 역할을 맡는다.
- 우선 ToInt32은 `ToNumber` 강제변환하고, `"123"`이라면 ToInt32 규칙을 적용하기 전 `123`으로 바꾼다.
- 엄밀히 말해 이 자체는 강제변환이 아니지만, 숫자 값에 `|`나 `~` 비트 연산자를 적용하면 전혀 다른 숫자 값을 생성하는 강제변환 효과가 있다.
- 예를 들어 아무 연산도 하지 않는 0 | x의 OR연산자(|)는 사실상 ToInt32 변환만 수행한다.

```javascript
0 | -0; // 0
0 | NaN; // 0
0 | Infinity; // 0
0 | -Infinity; // 0
```

- 이러한 특수 숫자들은 32비트로 나타내는 것이 불가능하므로 ToInt32 연산 결과는 0 이다.
- `~` 연산자는 먼저 32 비트 숫자로 강제변환한 후 `NOT` 연산을 한다.
- 이산 수학에서 **`~`는 2의 보수**를 구한다.
- 즉, `~x`는 `-(x+1)`와 같다.

```javascript
~42; // -(42+1) ==> -43
```
- 위 연산에서 결과를 0으로 만드는 유일한 값은 -1이다.
- 다시 말해, 일정 범위 내의 숫자 값에 `~` 연산을 할 경우 입력 값이 -1이면 (`false`로 쉽게 강제변환할 수 있는) `falsy`한 0, 그 외엔 `truthy`한 숫자 값이 산출된다.
- 여기서 -1과 같은 성질의 값을 **경계 값(Sentinel Value)** 라고 하는데, **동일 타입(숫자)의 더 확장된 값의 집합 내에서 임의의 어떤 의미를 부여한 값**이다.
- 자바스크립트는 문자열 메서드 `indexOf()`를 정의할 때 이 전례에 따라 특정 문자를 검색하고 발견하면 0부터 시작하는 숫자 값을, 발견하지 못했을 경우 -1을 반환한다.

```javascript
var a = 'Hello World';

if(a.indexOf('lo') >= 0) { // true
  // found it 
}
if(a.indexOf('lo') != -1) { // true
  // found it 
}
if(a.indexOf('ol') < 0) { // true
  // not found 
}
if(a.indexOf('ol') == -1) { // true
  // not found 
}
```

- 많이 지저분해 보인다. 기본적으로 이런 부류의 코드는 구멍 난 추상화(Leaky Abstraction), 즉 내부 구현 방식을 내가 짠 코드에 심어놓은 꼴이다.

```javascript
var a = 'Hello World';

~a.indexOf('lo'); // -4 <-- truthy!
if(~a.indexOf('lo')) { // true
  // found it
}
~a.indexOf('ol'); // 0 <-- falsy!
!~a.indexOf('lo'); // true
if(~a.indexOf('ol')) {// true
  // not found
}
```

**📌 비트 잘라내기**
- `~`의 용도가 하나 더 존재한다.
- 숫자의 소수점 이상 부분을 잘라내기 위해 더블 틸드(`~~`)를 사용하는 개발자들이 있는데 흔히, 이렇게 하면 `Math.floor()`와 같은 결과가 나온다고 생각한다.
- `~~`는 처음 `~`는 ToInt32 강제변환을 적용한 후 각 비트를 거꾸로한다.
- 그리고 두 번째 `~`는 비트를 또 한 번 뒤집는데, 결과적으로 원래 상태로 되돌린다.
- 결국 ToInt32 강제변환(잘라내기)만 하는 셈이다.
- 우선 `~~`연산은 **32 비트 값에 한아여 안전하지만 그보다도 음수에서는 `Math.floor()`과 결괏값이 다르다는 사실에 조심해야 한다.**

```javascript
Math.floor(-49.6); // -50
~~-49.6 // -49
```

- `Math.floor()`과 다른 점은 차치하더라도 `~~x`는(32비트) 정수로 상위 비트를 잘라낸다.
- 하지만 같은 일을 하는 `x | 0` 가(조금이라도) 더 빠를 것 같다. 그러면 왜 `~~x`를 써야 할까?
- 바로 연산자 우선순위 때문이다.

```javascript
~~1E20 / 10; // 166199296
1E20 | 0 / 10; //1661992960
(1E20 | 0) / 10; // 166199296
```

#### 📚 명시적 강제변환: 숫자 형태의 문자열 파싱

```javascript
var a = '42';
var b = '42px';

Number(a); // 42
parseInt(a); // 42

Number(b); // NaN
parseInt(b); // 42
```

- 문자열로 부터 숫자 값의 파싱은 비 숫자형 문자를 허용한다.
- 즉, 좌 ➡ 우 방향으로 파싱하다가 **숫자 같지 않은 문자를 만나면 즉시 멈춘다.**
- 반면 **강제변환은 비 숫자형 문자를 허용하지 않기 때문에 `NaN`** 를 리턴한다.
- 그렇기 때문에 파싱은 강제변환의 대안이 될 수 없다. 
- 우측에 비 숫자형 문자가 있을지 확실하지 않거나 별로 상관 없다면 문자열을 숫자로 파싱한다.
- `parseInt()`는 문자열에 쓰는 함수이다. 인자가 숫자라면 애당초 `parseInt()`를 쓸 이유가 없다.
- 인자가 비 문자열이면 제일 먼저 자동으로 문자열로 강제변환한다.
- **절대로 `parseInt()`에 비 문자열 값을 넘기지 말아야 한다.**


**📌 비 문자열 파싱**

```javascript
parseInt(1/0, 19); // 18
```
- 위 코드는 무한대를 정수로 파싱하면 당연히 무한대로 나와야 하지만 결과는 18이 나왔다.
- 먼저, 비 문자열을 `parseInt()` 첫 번째 인자로 넘긴 것 자체가 잘못되었다.
- 하지만 이런 상황이 닥쳐와도 자바스크립트 엔진은 비 문자열을 문자열로 최대한 강제변환하려고 노력한다.

```javascript
parseInt(new String('42')); // 42
```
- 위 코드는 비 문자열 인자를 받았으니 실행되지 말아야 할까?
- `String` 객체 래퍼가 `42`로 언박싱되기를 바란다면, 42가 먼저 `"42"`가 된 다음, 다시 42로 파싱되어 반환되는 게 정말 이상한 일인가?

```javascript
var a = {
  num: 21,
  toString: function() { return String(this.num * 2); }
};

parseInt(a); // 42
```

- 인자 값을 강제로 문자열로 바꾼 다음 파싱을 시작하는 `parseInt()`의 로직은 상당히 일리가 있다.
- 만약 무한대(1/0) 같은 값을 넘긴다면 어떤 문자열로 변환하는 것이 최선일까?
- 자바스크립트는 `Infinity`를 택했다.
- 그러면 `parseInt(1/0, 19)`는 `parseInt('Infinity', 19)` 인데, 어떻게 파싱되는 것일까?
- 첫 번째 문자 `I`는 19진수 18에 해당한다. 두 번째 `n`은 `0-9`, `a-i` 범위 밖의 문자이므로 파싱은 여기서 멈춘다.
- 그래서 결과는 18인 것이다.

```javascript
parseInt(0.000008); // 0
parseInt(0.0000008); // 8 ('8e-7' -> '8')
parseInt(false, 16); // 250 ('false' -> 'fa')
parseInt(parseInt, 16); // 15 ('function...', -> 'f')
parseInt('0x10'); // 16
parseInt('103', 2); // 2
```

#### 📚 명시적 강제변환: * ➡ 불리언
- `String()`, `Number()`도 그렇듯이 `Boolean()` 명시적인 강제변환 방법이다.(앞에 `new` x)

```javascript
var a = '0';
var b = [];
var c = {};

var d = '';
var e = 0;
var f = null;
var g;

Boolean(a); // true
Boolean(b); // true
Boolean(c); // true

Boolean(d); // false
Boolean(e); // false
Boolean(f); // false
Boolean(g); // false
```
- `Boolean()`은 명시적으지만 자주 쓰지이지 않는다.
- `+` 단항 연산자가 값을 숫자로 강제변환하는 것처럼 `!`부정 단한 연산자도 값을 불리언으로 명시적으로 강제변환한다.
- 문제는 그 과정에서 `truthy`, `falsy`까지 뒤바뀐다.
- 그래서 일반적으로 자바스크립트 개발 시 불리언 값으로 **명시적인 강제변환을 할 땐 `!!` 이중 부정 연산자를 사용한다.**
- 두 번째 `!`이 패리티를 다시 원상 복구 한다.

```javascript
var a = '0';
var b = [];
var c = {};

var d = '';
var e = 0;
var f = null;
var g;

!!a; // true
!!b; // true
!!c; // true

!!d; // false
!!e; // false
!!f; // false
!!g; // false
```
- 이 같은 `ToBoolean` 강제변환 모두 `Boolean()`이나 `!!`를 쓰지 않으면 `if()` 문 등의 불리언 콘텍스트에서 암시적인 강제변환이 일어난다.
- 여기서는 `ToBoolean` 강제변환의 원래 의도를 좀 더 명확히 구현하기 위해 값을 불리언으로 명시적인 강제변환을 했다.
- 자료 구조의 `JSON` 직렬화 시 `true/false` 값으로 강제변환하는 것도 명시적인 `ToBoolean` 강제변환의 일례이다.

```javascript
var a = [
  1,
  function(){/* ... */},
  2,
  function(){/* ... */},
];
JSON.stringify(a); // "[1,null,2,null]"

JSON.stringify(a, function(key, val) {
  if(typeof val == 'function') {
    // 함수를 ToBoolean 강제변환한다.
    return !!val;
  }
  else {
    return val
  }
});
// "[1,true,2,true]"
```
- 다음 코드는 `true/false` 중 하나가 결과가 도출된다는 점에서 명시적인 `ToBoolean` 강제변환의 모습과 닮았다.
```javascript
var a = 42;
var b = a ? true : false;
```
- 그러나 여기엔 암시적 강제변환이 매복해 있다.
- a를 일단 불리언으로 강제변환해야 표현식 전체의 `true/false` 여부를 따져볼 수 있기 때문이다.
- 이런 코드를 명시적으로 암시적이라하는대 이런 코드는 무조건 쓰지 말자.
- 이런 코드보단 `Boolean(a)`이나 `!!a`같은 명시적 강제변환이 훨씬 좋다.


### 🎯 암시적 변환
- 암시적 강제변환은 **부수 효과가 명확하지 않게 숨겨진 형태로 일어나는 타입변환**이다.

#### 📚 암시적이란?
- 엄격한 타입 언어(Strongly Typed Language)에서 말하는 이론적인 의사 코드를 살펴보자.

```
SomeType x = SomeType(AnotherType(y))
```
- 임의의 타입, y 값을 `SomeType` 타입으로 변환할 때 곧바로 변환할 수 없다.
- 다음과 같이 직접 기술한다고하자.

```
SomeType x = SomeType(y)
```
- 코드를 이렇게 쓸 수 있다면 중간 변환 단계를 줄여 타입변환을 단순화했다고 할 수 있을까?
- 실제로 코드 가독성을 높이고 세세한 구현부를 추상화하거나 감추는 데 도움이 된다고 생각한다.
- 위와 같은 이야기의 핵심은 자바스크립트의 암시적 강제변환 역시 같은 이치로 우리가 작성하는 코딩에 도움을 줄 수 있다.

#### 📚 암시적 강제변환: 문자열 ↔ 숫자
- 암시적 강제변환을 일으키는 몇 개의 연산들이 있다.
- `+` 연산자는 숫자의 덧셈과 문자열 접합 두 가지 목적으로 오버로드(Overload)된다.

```javascript
var a = '42';
var b = '0';

var c = 42;
var d = 0;

a + b; // '420'
c + d; // 42
```
- 피연산자가 한쪽 또는 양쪽 모두 문자열인지 아닌지에 따라 + 연산자가 문자열 붙이기를 할지 결정한다고 하지만, 부분적으로는 맞지감 실상은 그보다 더 복잡하다.

```javascript
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

- ES5 11.6.1에 따르면 `+` 알고리즘(피연산자가 객체 값일 경우)은 한쪽 연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.
- 따라서 피연산자 중 하나가 객체(배열 포함)라면, 먼저 이 값에 `ToPrimitive` 추상 연산을 수행하고, 다시 `ToPrimitive`는 `number` 콘텍스트 힌트를 넘겨 `[[DefaultValue]]` 알고리즘을 호출한다. 
- `valueOf()`에 배열을 넘기면 단순 원시 값을 반환할 수 없으므로 `toString()`으로 넘어간다.
- 그래서 두 배열은 `"1,2"`와 `"3,4"`가 되고, `+`는 두 문자열을 붙여 최종 결괏값은 `"1,23,4"`가 된다.

```javascript
var a = [1,2];
var b = [3,4];

valueOf(a); // Uncaught TypeError: Cannot convert undefined or null to object
a.toString() + b.toString(); // "1,23,4"

a+b; // "1,23,4"
```

- `+`연산의 한쪽 피연산자가 문자열이면 `+`는 문자열 붙이기 연산을 한다. 그 밖에는 언제나 숫자 덧셈을 한다.
- 숫자는 공백 문자열 `''`와 더하면 문자열로 강제변환된다.

```javascript
var a = 42;
var b = a + '';

b; // '42'
```

- 명시적 강제변환 `String(a)`에 비해 암시적 강제변환 `a + ""`에서는 한 가지 유의해야 할 사항이 있다.
- `ToPrimitive` 연산 과정에서 `a + ''`는 `a` 값을 **`valueOf()` 메서드에 전달하여 호출**하고, 그 결괏값은 **`ToString` 추상 연산을 하여 최종적인 문자열**로 변환된다.
- 그러나 **`String(a)`는 `toString()`를 직접 호출할 뿐이다.**
- 두 방법 모두 궁극적으로 변환된 문자열을 반환하지만 평범한 원시 숫자 값이 아닌 **객체라면 결괏값이 달라질 수 있다.**

```javascript
var a = {
  valueOf: function(){ return 42; },
  toString: function(){ return 4; },
};

a + ''; // '42'
String(a); // '4'
```

- 문자열 ➡ 숫자인 암시적인 강제변환은 어떨까?

```javascript
var a = '3.14';
var b = a - 0;

b; // 3.14
```

- `-`연산자는 숫자 뺄셈 기능이 전부이므로 `a - 0`은 `a` 값을 숫자로 강제변환한다.
- 객체 값에 `-`연산을 하면 이전의 `+`와 비슷하다.

```javascript
var a = [3];
var b = [1];

a - b; // 2
```
- 두 배열은 우선 문자열로 강제변환 뒤(toString()로 직렬화) 숫자로 강제변환된다.
- 그리고 마지막엔 `-` 연산을 한다.
- `b = String(a)` (명시적)과 `b = a + ''`(암시적) 둘 다 경우에 따라 유용하게 코그에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이 사용한다.